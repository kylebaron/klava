---
title: "optimhelp"
author: "Kyle"
date: "April 1, 2016"
output: 
  md_document:
  variant: markdown_github
---

```{r,echo=FALSE}
knitr::opts_chunk$set(comment='.',fig.path="img/README-")

```


# optimhelp

```{r}
library(optimhelp)
library(ggplot2)
```

So far, this is  a __parameter management system__.  I can name and set initial values
for parameters in a model.  I can also specify a transformation
for each parameter: the value is transformed to a different scale for estimation and 
it can be transformed back when either getting a prediction or after the optimization is finished.  Also, `parlist` objects allow you to fix parameters in the optimization.

In this example, both `CL` and `VC` are estimated as log-transformed values.
```{r}
cl <- log_par("CL", 1.2)
vc <- log_par("VC", 22.3)

```

```{r}
cl
```



Make a `parlist` object
```{r}
p <- new_pars(cl,vc)
```


The parlist object
```{r}
p
```

Check what the transformed values look like
```{r}
trans(p)
```


or generate initial values on the estimation scale
```{r}
start.values <- initials(p)
start.values
```

Grafting back into the `parlist` object gets us untransformed (by default)
```{r}
graft(p,start.values + 0.5)
```



# Examples


## Simulate some data
```{r}
set.seed(292)

x <- runif(300,10,300)
y <- (0.1 + 0.9*x/(100+x))*exp(rnorm(length(x),0,sqrt(0.025)))
data <- data.frame(x=x,y=y)
head(data)

qplot(x,y,data=data, geom="point")
```


## Specify parameters
We will restrict emax to be between 0 and 1 for now.  Also sending a fixed 
parameter through for fun
```{r}
emax <- logit_par("emax", 0.6)
ec50 <- log_par("ec50", 60)
e0 <- ident_par("e0", 0.1, fixed=TRUE)
p <- new_pars(emax,ec50,e0)
p

```



## Fit with `optim`
In the `pred` function below

  1. Graft the estimated proposed by the optimzer back into the `parlist` object
      * By default, grafting untransforms all values in the `parlist`
  1. Coerce to `list` so we can use to generate predictions
  
```{r}

pred <- function(est,p, x,pred=FALSE) {
  est <- as.list(graft(p,est))
  yhat <- est$e0 + est$emax*x/(x+est$ec50)
  if(pred) return(yhat)
  sqres <- (y-yhat)^2
  return(sum(sqres))
}

```

1. Use `initials` to transform the starting values at the start of the optimization
1. Pass the `parlist` object into the prediction function so we can graft the estimates back in
```{r}

fit <- optim(par=initials(p),fn=pred,p=p,x=x)
````

Notice that, when we passed in the starting estimates, `optim` doesn't get exposed
to any fixed parameter
```{r}
initials(p)
```

After the fitting is done, graft the final estimates
back into the `parlist` and take a look.
```{r}
est <- graft(p,fit$par)

est
```

A `coef` method will give just the non-fixed values
```{r}
coef(est)
```

Otherwise, we can get everything like this
```{r}
as.numeric(est)
```


Check things out
```{r}
data$pred <- pred(initials(est),p,x,pred=TRUE)

ggplot(data) + 
  geom_point(aes(x,y),    col="darkslateblue") + 
  geom_point(aes(x,pred), col="firebrick")
```



## Fit with `nls`

Here, we'll access values from the `parlist` object with `$`
```{r}
prednls <- function(p, x, emax,ec50, pred=FALSE) {
  est <- graft(p,c(emax=emax,ec50=ec50))
  yhat <- est$e0 + est$emax*x/(x+est$ec50)
  return(yhat)
}

fit <- nls(y~prednls(p=p,x=x,emax,ec50),data=data, start=initials(p))

fit

est <- graft(p,coef(fit))

coef(est)

coef(fit)

est

```






